# ==========================================
# CSV ETL Script for SQL Server with SqlBulkCopy and Archiving
# ==========================================

# Configuration
$ServerName = ""                              # SQL Server name or IP address
$Database = "ClaimsStage"                     # Database to store the data
$FolderPath = ""                              # Directory containing CSV files to process
$DataMappingTable = "ETL.Claim_Data_Mapping"  # Table containing column mappings
$TableMappingTable = "ETL.Table_Mapping"      # Table mapping FilePattern to TargetTable

# Function: Log a message to the database
function Log_Message {# ==========================================
# Optimized CSV ETL Script for SQL Server
# ==========================================

# Configuration
$ServerName = ""                              # SQL Server name or IP address
$Database = "ClaimsStage"                     # Database to store the data
$FolderPath = ""                              # Directory containing CSV files to process
$DataMappingTable = "ETL.Claim_Data_Mapping"  # Table containing column mappings
$TableMappingTable = "ETL.Table_Mapping"      # Table mapping FilePattern to TargetTable

# Function: Log a message to the database
function Log_Message {
    param ([string]$Message)
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogQuery = @"
    INSERT INTO ETL.Payor_Log (Timestamp, PayorName, LogMessage)
    VALUES ('$Timestamp', '$PayorName', '$Message');
"@
    try {
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $LogQuery -TrustServerCertificate
    } catch {
        Write-Host "Failed to log message to database: $_"
    }
}

# Process files in the folder
$Files = Get-ChildItem -Path $FolderPath -Filter "*.csv"
if ($Files.Count -eq 0) {
    Write-Host "No CSV files found in folder: $FolderPath"
    exit
}

foreach ($File in $Files) {
    $FilePath = $File.FullName
    $SourceFileName = $File.Name

    # Fetch table mapping for CSV files only
    $TableMappingQuery = @"
    SELECT PayorName, TargetTable, FilePattern, ArchivePath
    FROM $TableMappingTable
    WHERE FileType = 'CSV' AND '$SourceFileName' LIKE REPLACE(FilePattern, '*', '%');
"@
    try {
        $TableMapping = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $TableMappingQuery -TrustServerCertificate
        if ($TableMapping.Count -eq 0) {
            Log_Message "No table mapping found for CSV file: $SourceFileName."
            continue
        }
        $PayorName = $TableMapping.PayorName
        $TargetTable = $TableMapping.TargetTable
        $ArchiveBasePath = $TableMapping.ArchivePath
        Log_Message "Mapping found for file: $SourceFileName, $PayorName targeting table: $TargetTable."
    } catch {
        Log_Message "Failed to retrieve table mapping for CSV file: $SourceFileName : $_"
        continue
    }

    # Determine archive folder path
    $CurrentYearMonth = (Get-Date).ToString("yyyyMM")
    $ArchivePath = Join-Path -Path $ArchiveBasePath -ChildPath $CurrentYearMonth

    # Create archive folder if it doesn't exist
    if (-not (Test-Path -Path $ArchivePath)) {
        try {
            New-Item -ItemType Directory -Path $ArchivePath -Force | Out-Null
            Log_Message "Created archive folder: $ArchivePath."
        } catch {
            Log_Message "Failed to create archive folder: $ArchivePath : $_"
            continue
        }
    }

    # Truncate target table
    $TruncateQuery = "TRUNCATE TABLE $TargetTable;"
    try {
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $TruncateQuery -TrustServerCertificate
        Log_Message "Staging table $TargetTable truncated successfully."
    } catch {
        Log_Message "Failed to truncate table $TargetTable : $_"
        continue
    }

    # Fetch column mappings
    $MappingQuery = @"
    SELECT IncomingColumnName, StandardizedColumnName
    FROM $DataMappingTable
    WHERE PayorName = '$PayorName';
"@
    try {
        $Mappings = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $MappingQuery -TrustServerCertificate
        if ($Mappings.Count -eq 0) {
            Log_Message "No column mappings found for PayorName: $PayorName."
            continue
        }
        Log_Message "Fetched column mappings successfully for PayorName: $PayorName."
    } catch {
        Log_Message "Failed to retrieve column mappings: $_"
        continue
    }

    # Pre-compute column indices based on header
    $Header = Get-Content -Path $FilePath -TotalCount 1 | ConvertFrom-Csv -Delimiter ',' | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name
    $ColumnIndexMap = @{}
    foreach ($Mapping in $Mappings) {
        $IncomingColumn = $Mapping.IncomingColumnName
        $StandardizedColumn = $Mapping.StandardizedColumnName
        $Index = [Array]::IndexOf($Header, $IncomingColumn)
        if ($Index -ge 0) {
            $ColumnIndexMap[$StandardizedColumn] = $Index
        } else {
            Log_Message "Column not found in header: $IncomingColumn"
        }
    }

    # Use SqlBulkCopy to stream rows into the database
    $ConnectionString = "Server=$ServerName;Database=$Database;Integrated Security=True;TrustServerCertificate=True;"
    try {
        $SqlBulkCopy = New-Object Data.SqlClient.SqlBulkCopy($ConnectionString, [Data.SqlClient.SqlBulkCopyOptions]::KeepIdentity)
        $SqlBulkCopy.DestinationTableName = $TargetTable
        $SqlBulkCopy.BatchSize = 10000

        # Map columns
        foreach ($Key in $ColumnIndexMap.Keys) {
            $SqlBulkCopy.ColumnMappings.Add($Key, $Key) | Out-Null
        }

        # Stream CSV rows and populate SqlBulkCopy
        $Stream = New-Object System.IO.StreamReader($FilePath)
        try {
            # Skip the header row
            $Stream.ReadLine() | Out-Null

            while (($Line = $Stream.ReadLine()) -ne $null) {
                $Values = $Line -split ',' | ForEach-Object { $_.Trim('"') }
                $Row = @{}
                foreach ($Key in $ColumnIndexMap.Keys) {
                    $Index = $ColumnIndexMap[$Key]
                    $Row[$Key] = if ($Index -lt $Values.Count) { $Values[$Index] } else { $null }
                }
                $SqlBulkCopy.WriteToServer(@($Row))
            }
        } finally {
            $Stream.Close()
        }

        Log_Message "Data successfully inserted into $TargetTable using SqlBulkCopy."
    } catch {
        Log_Message "Failed to bulk insert data for file: $SourceFileName : $_"
        continue
    } finally {
        $SqlBulkCopy.Close()
    }

    # Archive the file
    $ArchiveFilePath = Join-Path -Path $ArchivePath -ChildPath $SourceFileName
    try {
        Move-Item -Path $FilePath -Destination $ArchiveFilePath -Force
        Log_Message "File archived successfully to: $ArchiveFilePath."
    } catch {
        Log_Message "Failed to archive file: $SourceFileName to $ArchiveFilePath : $_"
    }
}

# Final log
Log_Message "CSV ETL process completed for all files in folder: $FolderPath."

    param ([string]$Message)
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogQuery = @"
    INSERT INTO ETL.Payor_Log (Timestamp, PayorName, LogMessage)
    VALUES ('$Timestamp', '$PayorName', '$Message');
"@
    try {
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $LogQuery -TrustServerCertificate
    } catch {
        Write-Host "Failed to log message to database: $_"
    }
}

# Process files in the folder
$Files = Get-ChildItem -Path $FolderPath -Filter "*.csv"
if ($Files.Count -eq 0) {
    Write-Host "No CSV files found in folder: $FolderPath"
    exit
}

foreach ($File in $Files) {
    $FilePath = $File.FullName
    $SourceFileName = $File.Name

    # Fetch table mapping for CSV files only
    $TableMappingQuery = @"
    SELECT PayorName, TargetTable, FilePattern, ArchivePath
    FROM $TableMappingTable
    WHERE FileType = 'CSV' AND '$SourceFileName' LIKE REPLACE(FilePattern, '*', '%');
"@
    try {
        $TableMapping = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $TableMappingQuery -TrustServerCertificate
        if ($TableMapping.Count -eq 0) {
            Log_Message "No table mapping found for CSV file: $SourceFileName."
            continue
        }
        $PayorName = $TableMapping.PayorName
        $TargetTable = $TableMapping.TargetTable
        $ArchiveBasePath = $TableMapping.ArchivePath
        Log_Message "Mapping found for file: $SourceFileName, $PayorName targeting table: $TargetTable."
    } catch {
        Log_Message "Failed to retrieve table mapping for CSV file: $SourceFileName : $_"
        continue
    }

    # Determine archive folder path
    $CurrentYearMonth = (Get-Date).ToString("yyyyMM")
    $ArchivePath = Join-Path -Path $ArchiveBasePath -ChildPath $CurrentYearMonth

    # Create archive folder if it doesn't exist
    if (-not (Test-Path -Path $ArchivePath)) {
        try {
            New-Item -ItemType Directory -Path $ArchivePath -Force | Out-Null
            Log_Message "Created archive folder: $ArchivePath."
        } catch {
            Log_Message "Failed to create archive folder: $ArchivePath : $_"
            continue
        }
    }

    # Truncate target table
    $TruncateQuery = "TRUNCATE TABLE $TargetTable;"
    try {
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $TruncateQuery -TrustServerCertificate
        Log_Message "Staging table $TargetTable truncated successfully."
    } catch {
        Log_Message "Failed to truncate table $TargetTable : $_"
        continue
    }

    # Fetch column mappings
    $MappingQuery = @"
    SELECT IncomingColumnName, StandardizedColumnName
    FROM $DataMappingTable
    WHERE PayorName = '$PayorName';
"@
    try {
        $Mappings = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $MappingQuery -TrustServerCertificate
        if ($Mappings.Count -eq 0) {
            Log_Message "No column mappings found for PayorName: $PayorName."
            continue
        }
        Log_Message "Fetched column mappings successfully for PayorName: $PayorName."
    } catch {
        Log_Message "Failed to retrieve column mappings: $_"
        continue
    }

    # Create DataTable for SqlBulkCopy
    $DataTable = New-Object System.Data.DataTable
    foreach ($Column in $Mappings.StandardizedColumnName) {
        $DataTable.Columns.Add($Column) | Out-Null
    }

    # Read CSV and populate DataTable
    try {
        $CsvLines = Get-Content -Path $FilePath | Select-Object -Skip 1
        #Write-Host "Lines read from CSV: $($CsvLines.Count)"  # Log the number of lines read

        if (-not $CsvLines) {
            Log_Message "The CSV file is empty or does not contain valid data: $SourceFileName."
            continue
        }

        foreach ($Line in $CsvLines) {
            #Write-Host "Processing line: $Line"
            
            # Initialize a new row for the DataTable
            $Row = $DataTable.NewRow()

            # Split the line into values
            $Values = $Line -split ','
            if (-not $Values) {
                Log_Message "Line splitting failed or returned no values for line: $Line in file: $SourceFileName."
                continue
            }

            # Populate the DataTable row based on column mappings
            foreach ($Mapping in $Mappings) {
                $IncomingColumn = $Mapping.IncomingColumnName
                $StandardizedColumn = $Mapping.StandardizedColumnName

                # Find the index of the column in the incoming data
                $Index = [Array]::IndexOf($Mappings.IncomingColumnName, $IncomingColumn)
                if ($Index -ge 0 -and $Index -lt $Values.Count) {
                    $Value = $Values[$Index].Trim().Trim('"') # Remove leading/trailing spaces and double quotes
                    #Write-Host "Mapping: $IncomingColumn -> $StandardizedColumn, Value: $Value"
                    $Row[$StandardizedColumn] = $Value
                } else {
                    #Log_Message "Column not found or index out of range: $StandardizedColumn (Index: $Index). Assigning NULL."
                    $Row[$StandardizedColumn] = [DBNull]::Value
                }
            }

            # Assign SourceFileName for each row
            $Row["SourceFileName"] = $SourceFileName
            #Write-Host "Assigned SourceFileName: $SourceFileName to row."

            $DataTable.Rows.Add($Row)
        }
        Log_Message "CSV data loaded into DataTable for file: $SourceFileName."
    } catch {
        Log_Message "Failed to process CSV file: $SourceFileName : $_"
        continue
    }

    # Use SqlBulkCopy to insert data
    $ConnectionString = "Server=$ServerName;Database=$Database;Integrated Security=True;TrustServerCertificate=True;"
    try {
        $SqlBulkCopy = New-Object Data.SqlClient.SqlBulkCopy($ConnectionString, [Data.SqlClient.SqlBulkCopyOptions]::KeepIdentity)
        $SqlBulkCopy.DestinationTableName = $TargetTable
        $SqlBulkCopy.BatchSize = 10000

        # Map all columns, including SourceFileName
        foreach ($Column in $DataTable.Columns) {
            $SqlBulkCopy.ColumnMappings.Add($Column.ColumnName, $Column.ColumnName) | Out-Null
        }

        $SqlBulkCopy.WriteToServer($DataTable)
        Log_Message "Data successfully inserted into $TargetTable using SqlBulkCopy."
    } catch {
        Log_Message "Failed to bulk insert data for file: $SourceFileName : $_"
        continue
    } finally {
        $SqlBulkCopy.Close()
    }

    # Archive the file
    $ArchiveFilePath = Join-Path -Path $ArchivePath -ChildPath $SourceFileName
    try {
        Move-Item -Path $FilePath -Destination $ArchiveFilePath -Force
        Log_Message "File archived successfully to: $ArchiveFilePath."
    } catch {
        Log_Message "Failed to archive file: $SourceFileName to $ArchiveFilePath : $_"
    }
}

# Final log
Log_Message "CSV ETL process completed for all files in folder: $FolderPath."
