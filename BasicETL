# Configuration
$ServerName = "YourServerName"
$Database = "YourDatabase"
$FilePath = "C:\path\to\your\anthemfile.csv"
$PayorName = "Anthem"
$TargetTable = "Anthem.MemberShip"
$LogFile = "C:\path\to\your\etl_log.txt"

# Extract just the file name from the full file path
$SourceFileName = Split-Path -Path $FilePath -Leaf

# Function: Log a message to the log file
function Log-Message {
    param (
        [string]$Message
    )
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Add-Content -Path $LogFile -Value "$Timestamp - $Message"
}

# Start ETL process logging
Log-Message "ETL process started for PayorName: $PayorName."

# Section 1: Fetch Column Mappings (Acts as an Extract)
$MappingQuery = @"
SELECT IncomingColumnName, StandardizedColumnName
FROM dbo.DataMapping
WHERE PayorName = '$PayorName';
"@

try {
    $Mappings = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $MappingQuery
    Log-Message "Fetched column mappings successfully."
} catch {
    Log-Message "Failed to retrieve column mappings: $_"
    exit
}

if ($Mappings.Count -eq 0) {
    Log-Message "No mappings found for PayorName: $PayorName. Exiting script."
    exit
}

# Build mapping dictionary
$MappingDict = @{ }
foreach ($row in $Mappings) {
    $MappingDict[$row.IncomingColumnName] = $row.StandardizedColumnName
}
Log-Message "Mapping dictionary created with keys: $($MappingDict.Keys -join ', ')."

# Section 2: Verify File Exists
if (-not (Test-Path -Path $FilePath)) {
    Log-Message "File not found: $FilePath"
    exit
}

# Section 3: Load and Transform Data (Acts as a Transform)
try {
    # Detect if the file is a single-column CSV
    $FirstLine = Get-Content -Path $FilePath -First 1
    $IsSingleColumn = ($FirstLine -notmatch ",") -and ($FirstLine -match "\S")

    if ($IsSingleColumn) {
        # Transform single-column data into a structured format
        $csvContent = @()
        $ICNColumn = "ICN"
        $DataRows = Get-Content -Path $FilePath | Select-Object -Skip 1
        foreach ($row in $DataRows) {
            $csvContent += [PSCustomObject]@{ $ICNColumn = $row.Trim('"') }
        }
        Log-Message "Detected single-column CSV. Processed $($csvContent.Count) rows."
    } else {
        # Process as a standard CSV
        $csvContent = Import-Csv -Path $FilePath -Delimiter ',' -Quote '"'
        Log-Message "Loaded standard CSV file successfully with $($csvContent.Count) rows."
    }
} catch {
    Log-Message "Failed to load CSV file: $_"
    exit
}

$TransformedRows = @()
foreach ($row in $csvContent) {
    $Values = @()
    foreach ($IncomingColumn in $MappingDict.Keys) {
        # Handle specific mapping conditions
        switch ($MappingDict[$IncomingColumn]) {
            "GETDATE()" {
                $Values += "GETDATE()"  # EffectiveKey
            }
            "<SourceFileName>" {
                $Values += "'$($SourceFileName -replace "'", "''")'"  # SourceFileName
            }
            default {
                if ($row.PSObject.Properties[$IncomingColumn]) {
                    # Map normal columns
                    $Value = $row.$IncomingColumn -replace "'", "''"  # Escape single quotes
                    $Values += "'$Value'"
                } else {
                    # Handle missing values as NULL
                    $Values += "NULL"
                }
            }
        }
    }
    $TransformedRows += "($($Values -join ','))"
}

if ($TransformedRows.Count -eq 0) {
    Log-Message "No data to insert. Exiting script."
    exit
}

# Section 4: Build Insert Query (Acts as a Load)
$ColumnHeaders = $MappingDict.Values -join ","  # Include all mapped columns
$InsertQuery = @"
INSERT INTO $TargetTable ($ColumnHeaders)
VALUES
$($TransformedRows -join ",`n");
"@

Write-Host $InsertQuery  # Debugging: Print query for validation

# Section 5: Insert Data into the Database
try {
    Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $InsertQuery
    Log-Message "Data inserted successfully into $TargetTable."
} catch {
    Log-Message "Error inserting data: $_"
    Write-Host "Detailed Error: $($_.Exception.Message)"
}

# Finalize Logging
Log-Message "ETL process completed for PayorName: $PayorName."
