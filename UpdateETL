# ==========================================
# CSV ETL Script for SQL Server with SQL Bulk Copy and Archiving
# ==========================================

# Load Configuration
$configPath = "ETLConfig.json"
$config = Get-Content $configPath | ConvertFrom-Json

$ServerName = $config.ServerName
$Database = $config.Database
$FolderPath = $config.FolderPath
$DataMappingTable = $config.DataMappingTable
$TableMappingTable = $config.TableMappingTable
$BatchSize = $config.BatchSize

# Function: Log a message to the database
function Log_Message {
    param ([string]$PayorName, [string]$Message)
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogQuery = @"
    INSERT INTO ETL.Payor_Log (Timestamp, PayorName, LogMessage)
    VALUES ('$Timestamp', '$PayorName', '$Message');
"@
    try {
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $LogQuery -TrustServerCertificate
    } catch {
        Write-Host "Failed to log message to database: $_"
    }
}

# Function: Process a single file
function Process_File {
    param ([string]$FilePath)

    $SourceFileName = [System.IO.Path]::GetFileName($FilePath)

    try {
        # Fetch table mapping
        $TableMappingQuery = @"
        SELECT PayorName, TargetTable, FilePattern, ArchivePath
        FROM $TableMappingTable
        WHERE FileType = 'CSV' AND '$SourceFileName' LIKE REPLACE(FilePattern, '*', '%');
"@
        $TableMapping = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $TableMappingQuery -TrustServerCertificate
        if ($TableMapping.Count -eq 0) {
            Log_Message "N/A" "No table mapping found for CSV file: $SourceFileName."
            return
        }
        $PayorName = $TableMapping.PayorName
        $TargetTable = $TableMapping.TargetTable
        $ArchiveBasePath = $TableMapping.ArchivePath
        Log_Message $PayorName "Mapping found for file: $SourceFileName targeting table: $TargetTable."

        # Truncate table and get column mappings
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query "TRUNCATE TABLE $TargetTable;" -TrustServerCertificate
        $Mappings = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query @"
        SELECT IncomingColumnName, StandardizedColumnName
        FROM $DataMappingTable
        WHERE PayorName = '$PayorName';
"@ -TrustServerCertificate
        if ($Mappings.Count -eq 0) {
            Log_Message $PayorName "No column mappings found for PayorName: $PayorName."
            return
        }

        # Process CSV and Bulk Copy
        $SqlConnection = New-Object System.Data.SqlClient.SqlConnection
        $SqlConnection.ConnectionString = "Server=$ServerName;Database=$Database;Integrated Security=True;TrustServerCertificate=True;"
        $SqlConnection.Open()

        $BulkCopy = New-Object Data.SqlClient.SqlBulkCopy($SqlConnection)
        $BulkCopy.DestinationTableName = $TargetTable
        $BulkCopy.BatchSize = $BatchSize
        foreach ($Mapping in $Mappings) {
            $BulkCopy.ColumnMappings.Add($Mapping.IncomingColumnName, $Mapping.StandardizedColumnName)
        }

        $DataTable = Import-Csv -Path $FilePath
        $BulkCopy.WriteToServer($DataTable)
        $BulkCopy.Close()
        $SqlConnection.Close()

        # Archive the file
        $ArchivePath = Join-Path -Path $ArchiveBasePath -ChildPath (Get-Date -Format "yyyyMM")
        if (-not (Test-Path -Path $ArchivePath)) {
            New-Item -ItemType Directory -Path $ArchivePath | Out-Null
        }
        $ArchiveFilePath = Join-Path -Path $ArchivePath -ChildPath $SourceFileName
        Move-Item -Path $FilePath -Destination $ArchiveFilePath -Force
        Log_Message $PayorName "File processed and archived successfully to: $ArchiveFilePath."

    } catch {
        Log_Message "N/A" "Error processing file $SourceFileName: $_"
    } finally {
        if ($SqlConnection.State -eq [System.Data.ConnectionState]::Open) {
            $SqlConnection.Close()
        }
        if ($BulkCopy) {
            $BulkCopy.Dispose()
        }
    }
}

# Main: Process all files
$Files = Get-ChildItem -Path $FolderPath -Filter "*.csv"
if ($Files.Count -eq 0) {
    Write-Host "No CSV files found in folder: $FolderPath"
    exit
}

# Optional: Enable parallel processing if supported
foreach ($File in $Files) {
    Process_File $File.FullName
}

Log_Message "N/A" "CSV ETL process completed for all files in folder: $FolderPath."
