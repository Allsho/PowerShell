foreach ($Row in $CsvContent) {
    $Values = @()
    foreach ($IncomingColumn in $MappingDict.Keys) {
        $MappedColumn = $MappingDict[$IncomingColumn]
        switch ($MappedColumn) {
            "EffectiveKey" {
                $Parts = $SourceFileName -split '_'
                $Values += $Parts[2].Substring(0, 6)
            }
            "SourceFileName" {
                $Values += "'$($SourceFileName -replace "'", "''")'"
            }
            default {
                $Value = $Row.$IncomingColumn -replace "'", "''"
                if ($Value -ne "") {
                    $Values += "'$Value'"
                } else {
                    $Values += "NULL"
                }
            }
        }
    }
    $BatchRows += "($($Values -join ','))"
    $RowCounter++

    # Process batch when size is reached or at the end
    if ($RowCounter % $BatchSize -eq 0 -or $RowCounter -eq $CsvContent.Count) {
        if ($BatchRows.Count -gt 0) {  # Ensure there are rows to insert
            $BatchInsertQuery = @"
            INSERT INTO $TargetTable ($ColumnHeaders)
            VALUES
            $($BatchRows -join ",`n");
"@
            Write-Host "Executing Batch Insert Query: $BatchInsertQuery" # Debugging
            try {
                Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $BatchInsertQuery -TrustServerCertificate
                Log_Message "Inserted batch of $($BatchRows.Count) rows for file: $SourceFileName."
            } catch {
                Log_Message "Failed to insert batch for file: $SourceFileName : $_"
            }
        }
        # Clear batch memory properly
        $BatchRows = @()
    }
}
