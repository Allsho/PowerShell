# ==========================================
# Enhanced ETL Template Script with Mapping and BCP
# ==========================================

# Configuration
$ServerName = ""                              # SQL Server name or IP address
$Database = "ClaimsStage"                     # Database to store the data
$FolderPath = ""                              # Directory containing CSV files to process
$DataMappingTable = "ETL.Claim_Data_Mapping"  # Table containing column mappings
$TableMappingTable = "ETL.Table_Mapping"      # Table mapping FilePattern to TargetTable
$MappedFilePath = "$FolderPath\MappedFiles"   # Directory to store transformed files
$BCPPath = "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\bcp.exe"  # Path to bcp utility

# Create the MappedFiles directory if not exists
if (-not (Test-Path -Path $MappedFilePath)) {
    New-Item -ItemType Directory -Path $MappedFilePath | Out-Null
}

# Function: Log a message to the database
function Log_Message {
    param ([string]$Message)
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogQuery = @"
    INSERT INTO ETL.Payor_Log (Timestamp, PayorName, LogMessage)
    VALUES ('$Timestamp', '$PayorName', '$Message');
"@
    try {
        Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $LogQuery -TrustServerCertificate
    } catch {
        Write-Host "Failed to log message to database: $_"
    }
}

# Function: Execute BCP command
function Execute_BCP {
    param (
        [string]$BCPCommand
    )
    try {
        & $BCPCommand
        if ($LASTEXITCODE -ne 0) {
            throw "BCP command failed with exit code $LASTEXITCODE"
        }
    } catch {
        throw "Error executing BCP command: $_"
    }
}

# Process files in the folder
$Files = Get-ChildItem -Path $FolderPath -Filter "*.csv"
if ($Files.Count -eq 0) {
    Write-Host "No files found in folder: $FolderPath"
    exit
}

foreach ($File in $Files) {
    $FilePath = $File.FullName
    $SourceFileName = $File.Name

    # Fetch table mapping for FilePattern
    $TableMappingQuery = @"
    SELECT PayorName, TargetTable, FilePattern
    FROM $TableMappingTable
    WHERE '$SourceFileName' LIKE REPLACE(FilePattern, '*', '%');
"@
    try {
        $TableMapping = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $TableMappingQuery -TrustServerCertificate
        if ($TableMapping.Count -eq 0) {
            Log_Message "No table mapping found for file: $SourceFileName."
            continue
        }
        $PayorName = $TableMapping.PayorName
        $TargetTable = $TableMapping.TargetTable
        Log_Message "Mapping found for file: $SourceFileName, $PayorName targeting table: $TargetTable."
    } catch {
        Log_Message "Failed to retrieve table mapping for file: $SourceFileName : $_"
        continue
    }

    # Fetch column mappings
    $MappingQuery = @"
    SELECT IncomingColumnName, StandardizedColumnName
    FROM $DataMappingTable
    WHERE PayorName = '$PayorName';
"@
    try {
        $Mappings = Invoke-SqlCmd -ServerInstance $ServerName -Database $Database -Query $MappingQuery -TrustServerCertificate
        if ($Mappings.Count -eq 0) {
            Log_Message "No column mappings found for PayorName: $PayorName."
            continue
        }
        Log_Message "Fetched column mappings successfully for PayorName: $PayorName."
    } catch {
        Log_Message "Failed to retrieve column mappings: $_"
        continue
    }

    # Create mapping dictionary
    $MappingDict = @{ }
    foreach ($Row in $Mappings) {
        $MappingDict[$Row.IncomingColumnName] = $Row.StandardizedColumnName
    }

    # Transform CSV content
    $MappedFile = "$MappedFilePath\$SourceFileName"
    try {
        $CsvContent = Import-Csv -Path $FilePath -Delimiter ',' # -Quote '"'
        if ($CsvContent.Count -eq 0) {
            Log_Message "No data in file: $FilePath"
            continue
        }
        # Map and transform rows
        $TransformedRows = foreach ($Row in $CsvContent) {
            $MappedRow = @{}
            foreach ($IncomingColumn in $MappingDict.Keys) {
                $MappedColumn = $MappingDict[$IncomingColumn]
                switch ($MappedColumn) {
                    "EffectiveKey" {
                        $Parts = $SourceFileName -split '_'
                        $MappedRow[$MappedColumn] = $Parts[2].Substring(0, 6)
                    }
                    "SourceFileName" {
                        $MappedRow[$MappedColumn] = $SourceFileName
                    }
                    default {
                        $MappedRow[$MappedColumn] = $Row.$IncomingColumn
                    }
                }
            }
            New-Object PSObject -Property $MappedRow
        }
        # Export transformed rows to a new file
        $TransformedRows | Export-Csv -Path $MappedFile -NoTypeInformation
        Log_Message "Transformed file saved: $MappedFile"
    } catch {
        Log_Message "Failed to transform file: $SourceFileName : $_"
        continue
    }

    # Bulk Insert Transformed File with BCP
    try {
        $BCPCommand = "$BCPPath $Database.$TargetTable in $MappedFile -c -t, -S $ServerName -T"
        Execute_BCP -BCPCommand $BCPCommand
        Log_Message "BCP load completed for file: $SourceFileName into $TargetTable"
    } catch {
        Log_Message "BCP load failed for file: $SourceFileName : $_"
        continue
    }
}

# Final log
Log_Message "ETL process completed for all files in folder: $FolderPath."
